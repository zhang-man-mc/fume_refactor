1.店铺名字用一个列表保存。

2.建立一个店铺类，属性有店铺名，网址。
每个店铺对应一个实例

每个店铺对应的网址根据参数的不同，而变化出十几个，甚至过百个，那么店铺类属性网址，简单的列表肯定不合适。一是这些参数传递的时机不同，而且在实例类的同时需要构造出大量的网址，耦合严重。

获取数据的参数： 
店铺名，开始和结束时间，页大小，期待获取的页数page_num
**传递时机**：程序入口处

构造网址：
1.对中文店铺名进行二次加密
2.拼接参数条件
3.根据期待获取的页数，每页对应一个url，一个店铺对应page_num个url
**构造时机**：设置参数后，数据获取前

参数可以通过GUI实现



3.设置一个参数类或者配置文件

设置参数类好一点。更方便管理。类方法为@staticalmethod



` 虚构一个fume页面，数据先用html网页代替，不用每次模拟登陆`



爬取过程

1.遍历店铺

​	1.构造该店铺所有的url

​	2.遍历url

​	 	1.获取单页数据

​			1.记录获取的数据条数

​			2.若返回页的数据为空，则直接遍历下一个店铺。

​			3.处理数据格式

2.去重

3.记录总数据条数，打印结果等

4.写入数据库





本地虚构fume页面测试时，需要改动Request类的get()方法，并且需要改动FumeSpider的引入名称，避免与真实的Request类重复

现在数据获取的类FumeSprider，执行链路依赖requests和网络条件，这严格限制了单元测试的执行环境

1.利用mock方案

2.实现DIP

​	1.创建一个抽象。这个依赖关系主要目的是获取fume的页面文本，创建一个FumeWebPage的抽象，让它承担"提供页面文本"的职责。

​	2.底层模块：继承FumeWebPage抽象类

​			1.远程网络请求：RemoteFumePage

​			2.本地虚构页面：LocalFumePage

​	3.高层模块：传入FumeWebPage抽象类，调用FumeWebPage的get_page()方法。最后实例化一个符合FumeWebPage的具体实现









工具函数写上 ：
	店铺名加密以及网址的拼接

参数配置类也补上 ：
	基本配置类config 更多配置继承该类

循环爬取：
	这个循环是否可以写成装饰器，这样可以去掉显眼的两层for。
	装饰起参数为爬取的店铺列表，它会自动完成所以店铺的循环

抽象成所有的url一起爬取，不要管每个店铺对应的url。那么装饰器传入的形参就是所有的url，遍历所有url，每次调用爬取即可。
分两次单层for，一次生成所有url。一次爬取所有url





原来：

店铺名 日期 页大小 形成和店铺名强相关的url

  再遍历这些不同店铺的url,  再根据要爬取的页数，形参最后的url



url需要再最内层for循环形成，同时爬取



现在： 一次生成所有。 生成后再遍历爬取

​	

为数据获取函数，



装饰器：

1.用类装饰器修饰类方法

2.循环爬取后数据累加保存问题

3.爬取到的数据是html网页，需要同时去除